"""
Custom Skill Example

Demonstrates progressive skill loading and custom skill integration
with BAML + Anthropic Agent Skills.
"""

import asyncio
import logging
from typing import List

# Import BAML client (generated by baml-cli)
# from baml_client import b

from shared.config import load_config
from shared.utils import setup_logging, async_retry, SkillExecutionError


logger = logging.getLogger("baml_anthropic.custom_skill")


@async_retry(max_retries=3, initial_delay=1.0, backoff_factor=2.0)
async def process_with_custom_skill(
    task: str,
    skill_name: str,
) -> dict:
    """
    Process a task using a custom Agent Skill.

    This function demonstrates:
    - Custom skill integration
    - Flexible skill invocation
    - Metadata capture from skill execution
    - Success/failure handling

    Args:
        task: Description of the task to perform
        skill_name: Name of the custom skill to use

    Returns:
        SkillResult object with:
            - skill_used: Name of the skill that was invoked
            - output: Result from the skill execution
            - metadata: Information about the execution
            - success: Whether the execution succeeded
            - timestamp: When the execution occurred

    Raises:
        SkillExecutionError: If skill execution fails

    Example:
        >>> result = await process_with_custom_skill(
        ...     "Calculate the sum of 1 to 100",
        ...     "calculator"
        ... )
        >>> print(f"Result: {result['output']}")
    """
    logger.info(f"Processing task with skill: {skill_name}")
    logger.info(f"Task: {task}")

    try:
        # NOTE: This requires BAML client generation
        # Uncomment after running: baml-cli generate

        # Call BAML function (type-safe)
        # result = await b.ProcessWithCustomSkill(
        #     task=task,
        #     skill_name=skill_name
        # )

        # For demonstration purposes (before BAML generation)
        from datetime import datetime

        result = {
            "skill_used": skill_name,
            "output": f"Placeholder output from {skill_name} skill",
            "metadata": {
                "task": task,
                "execution_time_ms": "150",
                "tokens_used": "45",
            },
            "success": True,
            "timestamp": datetime.now().isoformat(),
        }

        logger.info(f"Skill execution {'succeeded' if result['success'] else 'failed'}")
        return result

    except Exception as e:
        logger.error(f"Skill execution failed: {e}")
        raise SkillExecutionError(f"Failed to execute skill {skill_name}: {e}") from e


async def analyze_task_and_load_skills(user_request: str) -> dict:
    """
    Analyze a task to determine what skills are needed (progressive disclosure).

    This demonstrates the progressive disclosure pattern: analyze the task first,
    then load only the skills that are actually needed.

    Args:
        user_request: User's request in natural language

    Returns:
        TaskAnalysis with required skills

    Example:
        >>> analysis = await analyze_task_and_load_skills(
        ...     "Analyze the sales report PDF and create a summary"
        ... )
        >>> print(f"Task type: {analysis['task_type']}")
        >>> print(f"Required skills: {analysis['required_skills']}")
    """
    logger.info(f"Analyzing task: {user_request}")

    try:
        # NOTE: This requires BAML client generation
        # Uncomment after running: baml-cli generate

        # Call BAML function (type-safe)
        # analysis = await b.AnalyzeTaskType(user_request=user_request)

        # Placeholder logic
        analysis = {
            "task_type": "document_analysis",
            "required_skills": ["pdf_reader", "summarizer"],
            "confidence": 0.92,
            "context": "User wants to analyze a PDF document and create a summary",
        }

        logger.info(f"Task classified as: {analysis['task_type']}")
        logger.info(f"Required skills: {analysis['required_skills']}")

        return analysis

    except Exception as e:
        logger.error(f"Task analysis failed: {e}")
        raise


async def progressive_skill_loading(
    task: str,
    available_skills: List[str],
) -> dict:
    """
    Load skills progressively based on task requirements.

    This demonstrates the progressive disclosure pattern:
    - Start with minimal skills
    - Load additional skills only when needed
    - Explain why each skill was loaded

    Args:
        task: Task to perform
        available_skills: List of all available skills

    Returns:
        SkillLoadingResult showing which skills were loaded and why

    Example:
        >>> result = await progressive_skill_loading(
        ...     "Analyze this PDF",
        ...     ["pdf_reader", "docx_parser", "calculator", "web_search"]
        ... )
        >>> print(f"Loaded: {result['loaded_skills']}")
        >>> print(f"Skipped: {result['skipped_skills']}")
    """
    logger.info(f"Progressive skill loading for task: {task}")
    logger.info(f"Available skills: {available_skills}")

    try:
        # NOTE: This requires BAML client generation
        # Uncomment after running: baml-cli generate

        # Call BAML function (type-safe)
        # result = await b.LoadSkillsProgressively(
        #     task=task,
        #     available_skills=available_skills
        # )

        # Placeholder logic demonstrating progressive disclosure
        result = {
            "loaded_skills": ["pdf_reader"],
            "loading_rationale": {
                "pdf_reader": "Task mentions analyzing a PDF document",
            },
            "skipped_skills": ["docx_parser", "calculator", "web_search"],
            "metrics": {
                "skills_available": float(len(available_skills)),
                "skills_loaded": 1.0,
                "efficiency_ratio": 0.25,  # Only loaded 25% of available skills
            },
        }

        logger.info(f"Loaded {len(result['loaded_skills'])} of {len(available_skills)} skills")
        logger.info(f"Efficiency: {result['metrics']['efficiency_ratio']:.0%}")

        return result

    except Exception as e:
        logger.error(f"Progressive skill loading failed: {e}")
        raise


async def main():
    """Example usage of custom skills and progressive disclosure."""
    # Load configuration
    config = load_config()
    setup_logging(config.log_level)

    try:
        # Example 1: Custom skill execution
        print("\n" + "=" * 60)
        print("EXAMPLE 1: CUSTOM SKILL EXECUTION")
        print("=" * 60)

        result = await process_with_custom_skill(
            task="Calculate the factorial of 10",
            skill_name="calculator",
        )

        print(f"\nSkill Used: {result['skill_used']}")
        print(f"Output: {result['output']}")
        print(f"Success: {result['success']}")
        print(f"Timestamp: {result['timestamp']}")
        print("\nMetadata:")
        for key, value in result['metadata'].items():
            print(f"  {key}: {value}")

        # Example 2: Task analysis
        print("\n" + "=" * 60)
        print("EXAMPLE 2: TASK ANALYSIS FOR SKILL LOADING")
        print("=" * 60)

        user_request = "I need to analyze the Q4 financial report PDF and identify trends"
        analysis = await analyze_task_and_load_skills(user_request)

        print(f"\nUser Request: {user_request}")
        print(f"\nTask Type: {analysis['task_type']}")
        print(f"Confidence: {analysis['confidence']:.0%}")
        print("\nRequired Skills:")
        for skill in analysis['required_skills']:
            print(f"  • {skill}")

        # Example 3: Progressive skill loading
        print("\n" + "=" * 60)
        print("EXAMPLE 3: PROGRESSIVE SKILL LOADING")
        print("=" * 60)

        task = "Analyze this PDF and extract the key metrics"
        available_skills = [
            "pdf_reader",
            "docx_parser",
            "excel_processor",
            "image_analyzer",
            "web_scraper",
            "calculator",
            "translator",
        ]

        loading_result = await progressive_skill_loading(task, available_skills)

        print(f"\nTask: {task}")
        print(f"\nAvailable Skills: {len(available_skills)}")
        print(f"Loaded Skills: {len(loading_result['loaded_skills'])}")
        print(
            f"Efficiency: {loading_result['metrics']['efficiency_ratio']:.0%} "
            "(only loaded what was needed!)"
        )

        print("\nSkills Loaded:")
        for skill in loading_result['loaded_skills']:
            rationale = loading_result['loading_rationale'][skill]
            print(f"  ✓ {skill}: {rationale}")

        print("\nSkills Skipped:")
        for skill in loading_result['skipped_skills']:
            print(f"  ✗ {skill}: Not needed for this task")

        print("\n" + "=" * 60)
        print("PROGRESSIVE DISCLOSURE PRINCIPLE")
        print("=" * 60)
        print(
            "\nBy loading only necessary skills, we:"
            "\n  • Reduce cognitive load on the agent"
            "\n  • Improve response time"
            "\n  • Lower token usage"
            "\n  • Make the system more maintainable"
        )
        print("\n" + "=" * 60)

    except Exception as e:
        logger.error(f"Example failed: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())
