<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storage & Persistence Tests - Weather Web</title>
    <style>
        .test-results { font-family: Arial, sans-serif; margin: 20px; }
        .test-pass { color: green; }
        .test-fail { color: red; }
        .test-section { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="test-results">
        <h1>Storage & Persistence Tests</h1>
        <div id="test-output"></div>
    </div>

    <script type="module">
        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.output = document.getElementById('test-output');
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async run() {
                let passed = 0;
                let failed = 0;

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.log(`✓ ${test.name}`, 'test-pass');
                        passed++;
                    } catch (error) {
                        this.log(`✗ ${test.name}: ${error.message}`, 'test-fail');
                        failed++;
                    }
                }

                this.log(`\nResults: ${passed} passed, ${failed} failed`, 
                         failed === 0 ? 'test-pass' : 'test-fail');
            }

            log(message, className = '') {
                const div = document.createElement('div');
                div.textContent = message;
                div.className = className;
                this.output.appendChild(div);
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(`${message}: expected ${expected}, got ${actual}`);
                }
            }

            assertDeepEqual(actual, expected, message) {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(`${message}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                }
            }
        }

        const runner = new TestRunner();

        // Clear localStorage before tests
        localStorage.clear();

        // StorageService Tests
        runner.test('StorageService can be instantiated', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            const storage = new StorageService();
            
            runner.assert(storage instanceof StorageService, 'StorageService should be instantiated');
            runner.assert(typeof storage.setItem === 'function', 'Should have setItem method');
            runner.assert(typeof storage.getItem === 'function', 'Should have getItem method');
        });

        runner.test('StorageService detects localStorage support', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const isSupported = StorageService.isSupported();
            runner.assertEqual(typeof isSupported, 'boolean', 'Should return boolean for localStorage support');
        });

        runner.test('StorageService stores and retrieves simple values', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.setItem('test_key', 'test_value');
            const retrieved = StorageService.getItem('test_key');
            
            runner.assertEqual(retrieved, 'test_value', 'Should store and retrieve string values');
        });

        runner.test('StorageService stores and retrieves objects', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const testObj = { name: 'London', temp: 20, nested: { value: true } };
            StorageService.setItem('test_object', testObj);
            const retrieved = StorageService.getItem('test_object');
            
            runner.assertDeepEqual(retrieved, testObj, 'Should store and retrieve objects');
        });

        runner.test('StorageService handles arrays correctly', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const testArray = ['London', 'Paris', 'New York'];
            StorageService.setItem('test_array', testArray);
            const retrieved = StorageService.getItem('test_array');
            
            runner.assertDeepEqual(retrieved, testArray, 'Should store and retrieve arrays');
        });

        runner.test('StorageService returns null for non-existent keys', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const retrieved = StorageService.getItem('non_existent_key');
            runner.assertEqual(retrieved, null, 'Should return null for non-existent keys');
        });

        runner.test('StorageService removes items correctly', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.setItem('remove_test', 'value');
            runner.assertEqual(StorageService.getItem('remove_test'), 'value', 'Item should exist');
            
            StorageService.removeItem('remove_test');
            runner.assertEqual(StorageService.getItem('remove_test'), null, 'Item should be removed');
        });

        runner.test('StorageService clears all items', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.setItem('clear_test_1', 'value1');
            StorageService.setItem('clear_test_2', 'value2');
            
            StorageService.clear();
            
            runner.assertEqual(StorageService.getItem('clear_test_1'), null, 'All items should be cleared');
            runner.assertEqual(StorageService.getItem('clear_test_2'), null, 'All items should be cleared');
        });

        runner.test('StorageService handles storage quota exceeded', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            // This test may not trigger quota exceeded in all browsers
            try {
                const largeData = 'x'.repeat(1000000); // 1MB string
                StorageService.setItem('large_data', largeData);
                runner.assert(true, 'Should handle large data or throw appropriate error');
            } catch (error) {
                runner.assert(error.message.includes('quota') || error.message.includes('storage'), 
                             'Should throw storage-related error');
            }
        });

        runner.test('StorageService validates item keys', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            try {
                StorageService.setItem('', 'value');
                runner.assert(false, 'Should reject empty key');
            } catch (error) {
                runner.assert(error.message.includes('key'), 'Should throw key validation error');
            }

            try {
                StorageService.setItem(null, 'value');
                runner.assert(false, 'Should reject null key');
            } catch (error) {
                runner.assert(error.message.includes('key'), 'Should throw key validation error');
            }
        });

        // Cache Management Tests
        runner.test('StorageService manages cache with TTL', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const cacheData = { data: 'test', timestamp: Date.now() };
            StorageService.setCacheItem('cache_test', cacheData, 1000); // 1 second TTL
            
            const retrieved = StorageService.getCacheItem('cache_test');
            runner.assertDeepEqual(retrieved.data, cacheData.data, 'Should retrieve cached data');
            
            // Test expiration (this is time-sensitive, so we simulate it)
            const expiredData = { data: 'expired', timestamp: Date.now() - 2000 };
            StorageService.setCacheItem('expired_test', expiredData, 1000);
            
            const expiredRetrieved = StorageService.getCacheItem('expired_test');
            runner.assertEqual(expiredRetrieved, null, 'Expired cache should return null');
        });

        runner.test('StorageService clears expired cache items', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            // Set items with different expiration times
            StorageService.setCacheItem('valid_cache', { data: 'valid' }, 10000);
            
            const expiredTime = Date.now() - 2000;
            const expiredItem = { data: 'expired', timestamp: expiredTime };
            localStorage.setItem('weather_cache_expired_cache', JSON.stringify({
                data: expiredItem,
                ttl: 1000,
                timestamp: expiredTime
            }));
            
            const initialCount = StorageService.getCacheKeys().length;
            const cleanedCount = StorageService.clearExpiredCache();
            
            runner.assert(cleanedCount > 0, 'Should clean expired cache items');
            runner.assertEqual(StorageService.getCacheItem('expired_cache'), null, 'Expired item should be removed');
        });

        // User Preferences Tests
        runner.test('StorageService manages user preferences', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const preferences = {
                temperatureUnit: 'celsius',
                theme: 'light',
                autoLocation: true
            };
            
            StorageService.setUserPreferences(preferences);
            const retrieved = StorageService.getUserPreferences();
            
            runner.assertDeepEqual(retrieved, preferences, 'Should store and retrieve user preferences');
        });

        runner.test('StorageService merges user preferences', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const initial = { temperatureUnit: 'celsius', theme: 'light' };
            const update = { autoLocation: true, theme: 'dark' };
            const expected = { temperatureUnit: 'celsius', theme: 'dark', autoLocation: true };
            
            StorageService.setUserPreferences(initial);
            StorageService.updateUserPreferences(update);
            const result = StorageService.getUserPreferences();
            
            runner.assertDeepEqual(result, expected, 'Should merge preferences correctly');
        });

        runner.test('StorageService manages temperature unit preference', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.setTemperatureUnit('fahrenheit');
            runner.assertEqual(StorageService.getTemperatureUnit(), 'fahrenheit', 'Should set temperature unit');
            
            StorageService.setTemperatureUnit('celsius');
            runner.assertEqual(StorageService.getTemperatureUnit(), 'celsius', 'Should update temperature unit');
        });

        // Recent Searches Tests
        runner.test('StorageService manages recent searches', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.addRecentSearch('London, GB');
            StorageService.addRecentSearch('Paris, FR');
            
            const searches = StorageService.getRecentSearches();
            runner.assert(searches.includes('London, GB'), 'Should contain London');
            runner.assert(searches.includes('Paris, FR'), 'Should contain Paris');
            runner.assertEqual(searches[0], 'Paris, FR', 'Most recent should be first');
        });

        runner.test('StorageService limits recent searches', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.clearRecentSearches();
            
            // Add more than the limit (assuming limit is 5)
            for (let i = 1; i <= 7; i++) {
                StorageService.addRecentSearch(`City${i}, XX`);
            }
            
            const searches = StorageService.getRecentSearches();
            runner.assert(searches.length <= 5, 'Should limit recent searches');
            runner.assertEqual(searches[0], 'City7, XX', 'Most recent should be first');
        });

        runner.test('StorageService prevents duplicate recent searches', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.clearRecentSearches();
            StorageService.addRecentSearch('London, GB');
            StorageService.addRecentSearch('Paris, FR');
            StorageService.addRecentSearch('London, GB'); // Duplicate
            
            const searches = StorageService.getRecentSearches();
            runner.assertEqual(searches.length, 2, 'Should not add duplicates');
            runner.assertEqual(searches[0], 'London, GB', 'Duplicate should move to front');
        });

        runner.test('StorageService clears recent searches', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.addRecentSearch('Test City, XX');
            runner.assert(StorageService.getRecentSearches().length > 0, 'Should have searches');
            
            StorageService.clearRecentSearches();
            runner.assertEqual(StorageService.getRecentSearches().length, 0, 'Should clear all searches');
        });

        // API Cache Tests
        runner.test('StorageService caches API responses', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const apiResponse = {
                name: 'London',
                main: { temp: 20, humidity: 60 },
                weather: [{ main: 'Clear', description: 'clear sky' }]
            };
            
            const cacheKey = 'weather_london_gb';
            StorageService.cacheAPIResponse(cacheKey, apiResponse, 600000); // 10 minutes
            
            const cached = StorageService.getCachedAPIResponse(cacheKey);
            runner.assertDeepEqual(cached, apiResponse, 'Should cache and retrieve API response');
        });

        runner.test('StorageService handles cache misses', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const cached = StorageService.getCachedAPIResponse('non_existent_cache');
            runner.assertEqual(cached, null, 'Should return null for cache miss');
        });

        runner.test('StorageService invalidates expired API cache', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const apiResponse = { data: 'test' };
            const cacheKey = 'expired_api_test';
            
            // Simulate expired cache by setting old timestamp
            const expiredTime = Date.now() - 20000; // 20 seconds ago
            localStorage.setItem(`weather_api_${cacheKey}`, JSON.stringify({
                data: apiResponse,
                ttl: 10000, // 10 seconds TTL
                timestamp: expiredTime
            }));
            
            const cached = StorageService.getCachedAPIResponse(cacheKey);
            runner.assertEqual(cached, null, 'Expired API cache should return null');
        });

        // Storage Statistics Tests
        runner.test('StorageService provides storage statistics', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const stats = StorageService.getStorageStats();
            
            runner.assert(typeof stats.used === 'number', 'Should provide used storage');
            runner.assert(typeof stats.available === 'number', 'Should provide available storage');
            runner.assert(typeof stats.total === 'number', 'Should provide total storage');
            runner.assert(stats.used >= 0, 'Used storage should be non-negative');
        });

        runner.test('StorageService provides cache statistics', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            StorageService.cacheAPIResponse('stats_test', { data: 'test' }, 600000);
            
            const stats = StorageService.getCacheStats();
            
            runner.assert(typeof stats.totalItems === 'number', 'Should provide total cache items');
            runner.assert(typeof stats.totalSize === 'number', 'Should provide total cache size');
            runner.assert(stats.totalItems > 0, 'Should count cache items');
        });

        // Error Handling Tests
        runner.test('StorageService handles localStorage unavailability gracefully', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            // Mock localStorage unavailable
            const originalLocalStorage = window.localStorage;
            Object.defineProperty(window, 'localStorage', {
                value: null,
                configurable: true
            });
            
            try {
                StorageService.setItem('test', 'value');
                const retrieved = StorageService.getItem('test');
                runner.assertEqual(retrieved, null, 'Should gracefully handle localStorage unavailability');
            } catch (error) {
                runner.assert(error.message.includes('not supported'), 'Should throw appropriate error');
            }
            
            // Restore localStorage
            Object.defineProperty(window, 'localStorage', {
                value: originalLocalStorage,
                configurable: true
            });
        });

        runner.test('StorageService handles JSON parse errors', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            // Set invalid JSON directly
            localStorage.setItem('weather_invalid_json', 'invalid json data');
            
            const retrieved = StorageService.getItem('invalid_json');
            runner.assertEqual(retrieved, null, 'Should handle JSON parse errors gracefully');
        });

        // Migration Tests
        runner.test('StorageService handles data migration', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            // Simulate old version data
            localStorage.setItem('old_weather_data', 'old_format_data');
            
            const migrated = StorageService.migrateOldData();
            runner.assert(typeof migrated === 'boolean', 'Should return migration status');
        });

        // Performance Tests
        runner.test('StorageService handles large datasets efficiently', async () => {
            const { StorageService } = await import('../js/utils/storage.js');
            
            const startTime = performance.now();
            
            // Store multiple items
            for (let i = 0; i < 100; i++) {
                StorageService.setItem(`perf_test_${i}`, { index: i, data: `test_data_${i}` });
            }
            
            // Retrieve multiple items
            for (let i = 0; i < 100; i++) {
                StorageService.getItem(`perf_test_${i}`);
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            runner.assert(duration < 1000, 'Should handle 200 operations in under 1 second');
        });

        // Run all tests
        runner.run();
    </script>
</body>
</html>