<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geolocation Integration Tests - Weather Web</title>
    <style>
        .test-results { font-family: Arial, sans-serif; margin: 20px; }
        .test-pass { color: green; }
        .test-fail { color: red; }
        .test-section { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="test-results">
        <h1>Geolocation Integration Tests</h1>
        <div id="test-output"></div>
    </div>

    <!-- Mock HTML structure for testing -->
    <div id="test-container" style="display: none;">
        <button id="get-location" class="location-btn">Use My Location</button>
        <div id="location-consent" class="location-consent">
            <div class="consent-message">This app would like to access your location to show local weather.</div>
            <button class="consent-allow">Allow</button>
            <button class="consent-deny">Deny</button>
        </div>
        <div id="location-error" class="location-error"></div>
    </div>

    <script type="module">
        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.output = document.getElementById('test-output');
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async run() {
                let passed = 0;
                let failed = 0;

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.log(`✓ ${test.name}`, 'test-pass');
                        passed++;
                    } catch (error) {
                        this.log(`✗ ${test.name}: ${error.message}`, 'test-fail');
                        failed++;
                    }
                }

                this.log(`\nResults: ${passed} passed, ${failed} failed`, 
                         failed === 0 ? 'test-pass' : 'test-fail');
            }

            log(message, className = '') {
                const div = document.createElement('div');
                div.textContent = message;
                div.className = className;
                this.output.appendChild(div);
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(`${message}: expected ${expected}, got ${actual}`);
                }
            }

            assertExists(selector, message, container = document) {
                const element = container.querySelector(selector);
                if (!element) {
                    throw new Error(`${message}: element ${selector} not found`);
                }
                return element;
            }
        }

        const runner = new TestRunner();

        // Mock geolocation API for testing
        const mockGeolocation = {
            getCurrentPosition: null, // Will be set in tests
            watchPosition: null,
            clearWatch: () => {},
        };

        // Store original geolocation
        const originalGeolocation = navigator.geolocation;

        // Mock WeatherService for testing
        class MockWeatherService {
            static async getCityFromCoordinates(lat, lon) {
                if (lat === 51.5074 && lon === -0.1278) {
                    return { name: 'London', country: 'GB' };
                }
                if (lat === 0 && lon === 0) {
                    throw new Error('Invalid coordinates');
                }
                return { name: 'Unknown City', country: 'XX' };
            }
        }

        runner.test('LocationService class can be instantiated', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            runner.assert(locationService instanceof LocationService, 'LocationService should be instantiated');
            runner.assert(typeof locationService.getCurrentLocation === 'function', 'Should have getCurrentLocation method');
            runner.assert(typeof locationService.requestPermission === 'function', 'Should have requestPermission method');
        });

        runner.test('LocationService detects geolocation support', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            const isSupported = locationService.isGeolocationSupported();
            runner.assertEqual(typeof isSupported, 'boolean', 'Should return boolean for geolocation support');
        });

        runner.test('LocationService handles permission states correctly', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            // Mock permission API
            const mockPermissions = {
                query: async () => ({ state: 'granted' })
            };
            
            Object.defineProperty(navigator, 'permissions', {
                value: mockPermissions,
                configurable: true
            });
            
            const permission = await locationService.checkPermissionStatus();
            runner.assert(['granted', 'denied', 'prompt'].includes(permission), 'Should return valid permission state');
        });

        runner.test('LocationService gets current location when permission granted', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            // Mock successful geolocation
            mockGeolocation.getCurrentPosition = (success) => {
                setTimeout(() => success({
                    coords: {
                        latitude: 51.5074,
                        longitude: -0.1278,
                        accuracy: 10
                    },
                    timestamp: Date.now()
                }), 10);
            };
            
            Object.defineProperty(navigator, 'geolocation', {
                value: mockGeolocation,
                configurable: true
            });
            
            const position = await locationService.getCurrentLocation();
            runner.assertEqual(position.coords.latitude, 51.5074, 'Should return correct latitude');
            runner.assertEqual(position.coords.longitude, -0.1278, 'Should return correct longitude');
        });

        runner.test('LocationService handles geolocation errors', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            // Mock geolocation error
            mockGeolocation.getCurrentPosition = (success, error) => {
                setTimeout(() => error({
                    code: 1,
                    message: 'User denied the request for Geolocation.'
                }), 10);
            };
            
            Object.defineProperty(navigator, 'geolocation', {
                value: mockGeolocation,
                configurable: true
            });
            
            try {
                await locationService.getCurrentLocation();
                runner.assert(false, 'Should throw error when geolocation fails');
            } catch (error) {
                runner.assert(error.message.includes('denied'), 'Should throw appropriate error');
            }
        });

        runner.test('LocationService converts coordinates to city', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            const cityInfo = await locationService.getCityFromCoordinates(51.5074, -0.1278);
            runner.assert(cityInfo.name, 'Should return city name');
            runner.assert(cityInfo.country, 'Should return country code');
        });

        runner.test('LocationService handles coordinate conversion errors', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            try {
                await locationService.getCityFromCoordinates(0, 0);
                runner.assert(false, 'Should throw error for invalid coordinates');
            } catch (error) {
                runner.assert(error.message, 'Should throw error with message');
            }
        });

        runner.test('LocationService manages user consent', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            // Test consent storage
            locationService.setUserConsent(true);
            runner.assertEqual(locationService.getUserConsent(), true, 'Should store and retrieve consent');
            
            locationService.setUserConsent(false);
            runner.assertEqual(locationService.getUserConsent(), false, 'Should update consent');
        });

        runner.test('LocationService provides user-friendly error messages', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            const permissionDeniedMsg = locationService.getErrorMessage(1);
            runner.assert(permissionDeniedMsg.includes('permission'), 'Should provide helpful message for permission denied');
            
            const unavailableMsg = locationService.getErrorMessage(2);
            runner.assert(unavailableMsg.includes('unavailable'), 'Should provide helpful message for position unavailable');
            
            const timeoutMsg = locationService.getErrorMessage(3);
            runner.assert(timeoutMsg.includes('timeout'), 'Should provide helpful message for timeout');
        });

        runner.test('LocationService handles location options correctly', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService({
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 60000
            });
            
            runner.assert(locationService.options.enableHighAccuracy, 'Should set high accuracy option');
            runner.assertEqual(locationService.options.timeout, 10000, 'Should set timeout option');
            runner.assertEqual(locationService.options.maximumAge, 60000, 'Should set maximum age option');
        });

        runner.test('LocationService provides location watching capability', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            let watchCallbackCalled = false;
            
            // Mock watch position
            mockGeolocation.watchPosition = (success) => {
                setTimeout(() => {
                    success({
                        coords: { latitude: 51.5074, longitude: -0.1278 },
                        timestamp: Date.now()
                    });
                }, 10);
                return 123; // Mock watch ID
            };
            
            Object.defineProperty(navigator, 'geolocation', {
                value: mockGeolocation,
                configurable: true
            });
            
            const watchId = await locationService.watchLocation((position) => {
                watchCallbackCalled = true;
                runner.assertEqual(position.coords.latitude, 51.5074, 'Watch should provide position');
            });
            
            setTimeout(() => {
                runner.assert(watchCallbackCalled, 'Watch callback should be called');
                runner.assertEqual(typeof watchId, 'number', 'Should return watch ID');
            }, 50);
        });

        runner.test('LocationService can clear location watching', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            let clearWatchCalled = false;
            
            mockGeolocation.clearWatch = (watchId) => {
                clearWatchCalled = true;
                runner.assertEqual(watchId, 123, 'Should clear correct watch ID');
            };
            
            Object.defineProperty(navigator, 'geolocation', {
                value: mockGeolocation,
                configurable: true
            });
            
            locationService.clearWatch(123);
            runner.assert(clearWatchCalled, 'Should call clearWatch');
        });

        runner.test('LocationService validates coordinates', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            runner.assertEqual(locationService.isValidCoordinate(51.5074, -0.1278), true, 'Valid coordinates should pass');
            runner.assertEqual(locationService.isValidCoordinate(91, 0), false, 'Invalid latitude should fail');
            runner.assertEqual(locationService.isValidCoordinate(0, 181), false, 'Invalid longitude should fail');
            runner.assertEqual(locationService.isValidCoordinate(null, 0), false, 'Null coordinates should fail');
            runner.assertEqual(locationService.isValidCoordinate(NaN, 0), false, 'NaN coordinates should fail');
        });

        runner.test('LocationService provides accuracy information', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            const locationService = new LocationService();
            
            const highAccuracy = locationService.getAccuracyLevel(5);
            runner.assertEqual(highAccuracy, 'high', 'Should identify high accuracy');
            
            const mediumAccuracy = locationService.getAccuracyLevel(50);
            runner.assertEqual(mediumAccuracy, 'medium', 'Should identify medium accuracy');
            
            const lowAccuracy = locationService.getAccuracyLevel(500);
            runner.assertEqual(lowAccuracy, 'low', 'Should identify low accuracy');
        });

        runner.test('LocationService handles browser compatibility', async () => {
            const { LocationService } = await import('../js/services/locationService.js');
            
            // Test without geolocation support
            Object.defineProperty(navigator, 'geolocation', {
                value: undefined,
                configurable: true
            });
            
            const locationService = new LocationService();
            runner.assertEqual(locationService.isGeolocationSupported(), false, 'Should detect lack of geolocation support');
            
            try {
                await locationService.getCurrentLocation();
                runner.assert(false, 'Should throw error when geolocation not supported');
            } catch (error) {
                runner.assert(error.message.includes('not supported'), 'Should throw appropriate error');
            }
        });

        // App integration tests
        runner.test('App initializes LocationService correctly', async () => {
            // Mock the app module import
            const mockApp = {
                locationService: null,
                init() {
                    this.locationService = { initialized: true };
                },
                handleLocationRequest() {
                    return 'location requested';
                }
            };
            
            mockApp.init();
            runner.assert(mockApp.locationService, 'App should initialize LocationService');
            runner.assertEqual(mockApp.handleLocationRequest(), 'location requested', 'App should handle location requests');
        });

        runner.test('App handles location button click', () => {
            const container = document.getElementById('test-container');
            const locationBtn = container.querySelector('#get-location');
            
            let clickHandled = false;
            locationBtn.addEventListener('click', () => {
                clickHandled = true;
            });
            
            locationBtn.click();
            runner.assert(clickHandled, 'Location button click should be handled');
        });

        runner.test('App shows consent UI when needed', () => {
            const container = document.getElementById('test-container');
            const consentDialog = container.querySelector('#location-consent');
            
            runner.assertExists('.consent-message', 'Should have consent message', container);
            runner.assertExists('.consent-allow', 'Should have allow button', container);
            runner.assertExists('.consent-deny', 'Should have deny button', container);
        });

        runner.test('App handles location errors gracefully', () => {
            const container = document.getElementById('test-container');
            const errorContainer = container.querySelector('#location-error');
            
            // Simulate error display
            errorContainer.textContent = 'Location access denied';
            errorContainer.style.display = 'block';
            
            runner.assert(errorContainer.textContent.includes('denied'), 'Should display error message');
        });

        // Restore original geolocation after tests
        runner.test('Cleanup: Restore original geolocation', () => {
            Object.defineProperty(navigator, 'geolocation', {
                value: originalGeolocation,
                configurable: true
            });
            runner.assert(true, 'Cleanup completed');
        });

        // Run all tests
        runner.run();
    </script>
</body>
</html>