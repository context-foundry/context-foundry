# Context Foundry Pattern Library

**Self-Learning Knowledge Base for Continuous Improvement**

This directory contains the accumulated learnings from all autonomous builds. Each file stores patterns, issues, and solutions discovered during builds.

---

## Pattern Files

### common-issues.json
**Purpose:** General issues encountered across all project types

**Schema:**
```json
{
  "pattern_id": "unique-id",
  "title": "Human-readable title",
  "first_seen": "YYYY-MM-DD",
  "last_seen": "YYYY-MM-DD",
  "frequency": 1,
  "severity": "HIGH|MEDIUM|LOW",
  "project_types": ["browser-app", "cli-tool", ...],
  "issue": {...},
  "root_cause": "Description",
  "solution": {
    "scout": {...},
    "architect": {...},
    "builder": {...},
    "test": {...}
  },
  "prevention": {
    "auto_apply": true/false,
    "conditions": [...],
    "actions": [...]
  }
}
```

### test-patterns.json
**Purpose:** Testing strategies and gaps discovered

Contains patterns for:
- Test coverage gaps
- Integration testing needs
- Browser compatibility checks
- Environment-specific tests

### architecture-patterns.json
**Purpose:** Proven architectural patterns from successful builds

Contains patterns for:
- Code organization strategies
- Design patterns that work well
- File structures
- Module separation approaches

### scout-learnings.json
**Purpose:** Risk detection and research insights

Contains patterns for:
- Risk flags to raise
- Technology compatibility issues
- Common pitfalls to warn about
- Questions to ask during research

---

## How Patterns Are Used

### Phase 1: Scout
1. Reads `scout-learnings.json` and `common-issues.json`
2. Identifies project type from task description
3. Flags risks matching this project type
4. Includes warnings in scout-report.md

### Phase 2: Architect
1. Reads `architecture-patterns.json` and `common-issues.json`
2. Applies proven architectural patterns
3. Includes preventive measures for flagged risks
4. Adds dependencies/config to prevent common issues

### Phase 4: Test
1. Reads `test-patterns.json` and `common-issues.json`
2. Runs pattern-based integration tests
3. Checks for known issues
4. Validates against project-type-specific requirements

### Phase 7: Feedback
1. Analyzes current build
2. Extracts new patterns
3. Updates existing patterns (increments frequency)
4. Stores learnings for future builds

---

## Pattern Lifecycle

### New Pattern
1. Discovered during feedback analysis
2. Added to appropriate JSON file
3. `frequency: 1`, `first_seen: today`
4. `auto_apply: false` initially

### Recurring Pattern
1. Seen in multiple builds
2. `frequency` incremented
3. `last_seen` updated
4. If `frequency >= 3`: Consider `auto_apply: true`

### Proven Pattern
1. High frequency (5+)
2. High success rate when applied
3. `auto_apply: true`
4. Scout/Architect phases apply automatically

### Stale Pattern
1. Not seen in 6+ months
2. Low frequency (< 3)
3. Marked for review/pruning

---

## Auto-Apply Logic

Patterns with `"auto_apply": true` are automatically applied when conditions match:

**Example:**
```json
{
  "auto_apply": true,
  "conditions": [
    "project_type includes 'browser'",
    "uses ES6 modules"
  ],
  "actions": [
    "Scout: Add CORS warning to scout-report.md",
    "Architect: Include http-server in package.json"
  ]
}
```

When Scout detects a browser app with ES6 modules:
1. Automatically flags CORS risk
2. Architect automatically includes dev server
3. No manual intervention needed
4. Issue prevented before it occurs

---

## Pattern Statistics

Each JSON file includes a `statistics` section:
```json
{
  "statistics": {
    "total_patterns": 5,
    "high_severity": 2,
    "medium_severity": 2,
    "low_severity": 1,
    "auto_apply_enabled": 3
  }
}
```

Track trends:
- Growth of pattern library over time
- Effectiveness (frequency of auto-applied patterns)
- Coverage (project types represented)

---

## Adding Patterns Manually

While patterns are auto-generated by Phase 7, you can manually add patterns:

1. Follow the schema in existing patterns
2. Assign unique `pattern_id`
3. Set `first_seen` to current date
4. Start with `frequency: 1` and `auto_apply: false`
5. Document thoroughly with examples
6. Test pattern application in a build

---

## Best Practices

✅ **Do:**
- Keep patterns specific and actionable
- Include concrete examples
- Document severity accurately
- Update `last_seen` when pattern recurs
- Provide clear solution steps for each phase

❌ **Don't:**
- Create duplicate patterns (check existing first)
- Leave vague descriptions
- Set `auto_apply: true` without testing
- Ignore low-frequency patterns (review and prune)

---

## Metrics to Track

**Pattern Library Health:**
- Total patterns across all files
- Auto-apply ratio (should increase over time)
- Average frequency (indicates pattern refinement)
- Pattern diversity (project types covered)

**Build Improvement:**
- Test iterations trend (should decrease)
- Build success rate (should increase)
- Common issue prevention rate
- Time saved per build

---

## Future Enhancements

- **Pattern Confidence Scores:** Based on success rate
- **Pattern Dependencies:** Some patterns require others
- **Pattern Conflicts:** Flag when patterns contradict
- **ML-Based Pattern Detection:** Automatically identify new patterns
- **Cross-Project Analysis:** Find patterns across multiple repositories

---

**Last Updated:** 2025-10-18
**Version:** 1.0.0
**Total Patterns:** 4 (across all files)
