# Implementation Plan: Todo Web Application
Generated: 2025-10-04T09:56:23Z
Context Usage: <5%

## Approach
Implement a client-server architecture with Express.js backend providing REST API endpoints and vanilla JavaScript frontend. Use Node.js native fs/promises for JSON file operations. Backend-first development approach allowing API testing before frontend implementation.

## Architecture Decisions

| Decision | Options Considered | Choice | Rationale |
|----------|-------------------|---------|-----------|
| Backend Framework | Express, Fastify, Native HTTP | Express | Most documentation, minimal learning curve, suitable for simple CRUD |
| Storage | JSON file, SQLite, In-memory | JSON file | Requirement specified, simplest persistence |
| ID Generation | UUID, Timestamp, Auto-increment | crypto.randomUUID() | No collision risk, Node.js built-in (v14.17+) |
| Frontend Framework | React, Vue, Vanilla JS | Vanilla JS | Minimal scope, no build step needed, reduces complexity |
| File Write Strategy | Direct write, Temp + rename, File locking | Temp + rename | Atomic operation, prevents corruption |
| API Style | REST, GraphQL, RPC | REST | Standard for CRUD, well-understood semantics |
| Error Handling | Try-catch, Error middleware | Both | Try-catch in routes, Express middleware for uncaught |
| Static Serving | Separate server, Express static | Express static | Single server simplifies deployment |

## Project Structure
```
todo-web/
├── package.json              # Dependencies and scripts
├── server.js                 # Express server entry point
├── data/
│   └── todos.json           # Persistent storage (auto-created)
├── routes/
│   └── todos.js             # API route handlers
├── utils/
│   └── storage.js           # File I/O abstraction
└── public/
    ├── index.html           # Main UI
    ├── style.css            # Styling
    └── app.js               # Frontend logic
```

## Implementation Phases

### Phase 1: Backend Foundation (Priority: Critical)
**Goal**: Set up Express server with static file serving and health check

**Deliverables**:
- package.json with dependencies (express, cors)
- server.js with Express setup
- Static file serving from /public directory
- Server starts on port 3000
- Basic error handling middleware

**Validation**: Server starts without errors, serves static files, responds to requests

### Phase 2: Storage Layer (Priority: Critical)
**Goal**: Implement file-based storage with atomic operations

**Deliverables**:
- utils/storage.js module
- readTodos() function with file initialization
- writeTodos() function with atomic write (temp + rename)
- Error handling for ENOENT, EACCES, JSON parse errors
- Auto-create data/todos.json with empty array

**Validation**: Can read/write todos.json, survives missing file, handles corrupt JSON

### Phase 3: API Endpoints (Priority: Critical)
**Goal**: Implement three REST endpoints

**Deliverables**:
- routes/todos.js with GET /api/todos
- POST /api/todos with validation
- PATCH /api/todos/:id/complete with 404 handling
- Proper HTTP status codes
- Request body validation

**Validation**: curl/Postman tests for all endpoints, error cases handled

### Phase 4: Frontend Structure (Priority: High)
**Goal**: Create HTML layout and basic styling

**Deliverables**:
- public/index.html with form and list container
- public/style.css with basic layout
- Semantic HTML structure
- Responsive form styling

**Validation**: Page loads, form displays, layout is functional

### Phase 5: Frontend Logic (Priority: High)
**Goal**: Implement JavaScript for API interaction

**Deliverables**:
- public/app.js with fetch calls
- loadTodos() on page load
- addTodo() form submission handler
- completeTodo() button click handler
- DOM manipulation for list updates
- Error display to user

**Validation**: Full workflow works: add → list → complete

### Phase 6: Polish & Error Handling (Priority: Medium)
**Goal**: Improve UX and robustness

**Deliverables**:
- Visual feedback for completed todos
- Loading states during API calls
- User-friendly error messages
- Input validation on frontend
- Empty state message when no todos

**Validation**: Application handles all edge cases gracefully

## Data Flow Diagrams

### Add Todo Flow
```
User Input → Frontend Validation → POST /api/todos
                                         ↓
                                    Validate Request
                                         ↓
                                    Read todos.json
                                         ↓
                                    Generate UUID
                                         ↓
                                    Append to Array
                                         ↓
                                    Write todos.json
                                         ↓
                                    Return 201 + Todo
                                         ↓
Frontend Updates DOM ← JSON Response ←─┘
```

### Complete Todo Flow
```
Button Click → PATCH /api/todos/:id/complete
                        ↓
                   Read todos.json
                        ↓
                   Find Todo by ID
                        ↓
                   Set completed=true
                        ↓
                   Set completedAt timestamp
                        ↓
                   Write todos.json
                        ↓
                   Return 200 + Todo
                        ↓
Frontend Updates DOM (strikethrough)
```

## Testing Strategy

### Backend Testing
- **Manual API Testing**: Use curl or Postman
  - GET /api/todos returns empty array initially
  - POST /api/todos creates todo and returns 201
  - POST with empty text returns 400
  - PATCH with valid ID marks complete
  - PATCH with invalid ID returns 404
  - File persists after server restart

### Frontend Testing
- **Browser Manual Testing**:
  - Form submission creates todo
  - List populates on page load
  - Complete button marks todo done
  - Visual feedback for completed state
  - Error messages display for failures

### Integration Testing
- **End-to-End Scenarios**:
  - Add 3 todos → refresh page → todos persist
  - Complete todos → refresh → state persists
  - Server restart → todos remain

### Edge Cases
- Empty todo text
- Very long todo text (>1000 chars)
- Rapid successive additions
- Missing data directory
- Corrupt JSON file
- Invalid UUID in URL

## Error Handling Strategy

### Backend Errors
| Error Type | HTTP Code | Response | Action |
|------------|-----------|----------|--------|
| Validation failure | 400 | `{ error: "Message" }` | Return immediately |
| Todo not found | 404 | `{ error: "Todo not found" }` | Check ID exists |
| File read error | 500 | `{ error: "Internal error" }` | Log, initialize if ENOENT |
| File write error | 500 | `{ error: "Internal error" }` | Log, retry once |
| JSON parse error | 500 | `{ error: "Internal error" }` | Log, backup file, reset |

### Frontend Errors
- Network errors: Display "Connection failed" message
- 4xx errors: Display validation message from server
- 5xx errors: Display "Server error, please try again"
- Timeout: Display "Request timed out"

## Risks & Mitigations

| Risk | Probability | Impact | Mitigation |
|------|------------|---------|------------|
| Concurrent write corruption | Low | High | Use temp file + rename (atomic); acceptable for single-user scope |
| File permission errors | Medium | High | Check permissions on startup, clear error messages |
| ID collision | Very Low | Medium | Use crypto.randomUUID() instead of timestamp |
| Large file performance | Low | Medium | Acceptable for <1000 todos; document limit |
| JSON parse errors | Low | High | Wrap in try-catch, backup before write, validate structure |
| Missing dependencies | Medium | High | Clear installation instructions in README |
| Port already in use | Medium | Low | Use process.env.PORT with fallback, error message |
| Browser compatibility | Low | Medium | Target modern browsers, document requirements |

## Performance Considerations
- Read entire file on each request (acceptable for <10KB files)
- No caching layer needed for single user
- Synchronous file operations acceptable (low volume)
- No indexing required for small datasets

## Security Considerations
- Input sanitization for XSS prevention (not storing HTML)
- No authentication required (localhost only)
- Path traversal prevention (no user-supplied file paths)
- CORS configured for localhost only

## Deployment Steps
1. Clone repository
2. Run `npm install`
3. Run `npm start`
4. Open browser to http://localhost:3000
5. data/todos.json auto-creates on first operation

## Success Metrics
- All three operations (add, list, complete) functional
- Data persists across server restarts
- Zero uncaught exceptions during normal operation
- Response time < 100ms for all operations
- Code is readable and follows consistent style

## Future Enhancements (Post-MVP)
- Delete functionality
- Edit todo text
- Filter by status (all/active/completed)
- Sort by date or completion status
- Bulk operations (complete all, delete completed)
- Export to CSV/JSON
- Import from file
- Dark mode toggle
- Keyboard shortcuts
- Migrate to SQLite for better performance
```

---

## **TASKS.md**

```markdown