# Research Report: Web-Based Todo App

Generated: 2025-10-04 09:42:44 UTC
Context Usage: <5%

## Architecture Overview

A lightweight web-based todo application with persistent storage using local JSON file. The architecture follows a simple client-server pattern with:
- **Frontend**: Single-page application (SPA) for user interaction
- **Backend**: REST API server handling business logic and file I/O
- **Storage**: JSON file for data persistence (no database required)

This is a new project starting from scratch with minimal dependencies and straightforward deployment.

## Recommended Technology Stack

### Backend Options
**Option 1: Python + Flask (Recommended)**
- Lightweight and easy to set up
- Built-in JSON handling
- Minimal dependencies: `flask`, `flask-cors`
- Native file I/O operations
- Good for rapid prototyping

**Option 2: Node.js + Express**
- JavaScript full-stack consistency
- Excellent async file operations
- Dependencies: `express`, `cors`, `body-parser`
- Native JSON support

### Frontend
- **Vanilla JavaScript** with HTML/CSS (no framework needed for simplicity)
- Alternative: Lightweight framework like Alpine.js or htmx for reactivity
- Fetch API for HTTP requests

### Storage
- Single `todos.json` file in project root or `data/` directory
- File locking considerations for concurrent access
- Backup mechanism recommended

## Project Structure

```
todo-web/
├── backend/
│   ├── app.py                 # Flask application entry point
│   ├── models.py              # Todo data model
│   ├── storage.py             # JSON file I/O operations
│   └── requirements.txt       # Python dependencies
├── frontend/
│   ├── index.html             # Main UI
│   ├── styles.css             # Styling
│   └── app.js                 # Client-side logic
├── data/
│   └── todos.json             # Storage file (created at runtime)
└── README.md                  # Setup instructions
```

## Data Models

### Todo Item
```json
{
  "id": "uuid-string",
  "title": "string",
  "description": "string (optional)",
  "completed": false,
  "created_at": "ISO-8601 timestamp",
  "completed_at": "ISO-8601 timestamp (nullable)"
}
```

### Storage Format (todos.json)
```json
{
  "todos": [
    { "id": "...", "title": "...", "completed": false, ... }
  ],
  "metadata": {
    "last_modified": "ISO-8601 timestamp",
    "version": "1.0"
  }
}
```

## API Design

### REST Endpoints

| Method | Endpoint | Description | Request Body | Response |
|--------|----------|-------------|--------------|----------|
| GET | `/api/todos` | List all todos | - | `{ "todos": [...] }` |
| POST | `/api/todos` | Add new todo | `{ "title": "...", "description": "..." }` | `{ "todo": {...} }` |
| PUT | `/api/todos/<id>/complete` | Mark as complete | - | `{ "todo": {...} }` |
| DELETE | `/api/todos/<id>` | Delete todo | - | `{ "success": true }` |
| GET | `/api/health` | Health check | - | `{ "status": "ok" }` |

## Implementation Patterns

### Backend Patterns

1. **File-based Storage Manager**
   - Singleton pattern for file access
   - Read-Modify-Write with file locking
   - Atomic writes using temp file + rename
   - Error handling for corrupted JSON

2. **Request Validation**
   - Title required (non-empty string)
   - ID validation for operations
   - Todo existence checks

3. **Error Responses**
   ```json
   {
     "error": "Error message",
     "code": "ERROR_CODE",
     "status": 400
   }
   ```

### Frontend Patterns

1. **State Management**
   - In-memory array synced with backend
   - Optimistic updates with rollback on failure

2. **UI Updates**
   - Dynamic DOM manipulation
   - Event delegation for todo items
   - Loading states during API calls

3. **Error Handling**
   - Toast notifications for errors
   - Retry mechanism for failed requests

## Data Flow

### Add Todo Flow
```
User Input → Frontend Validation → POST /api/todos → 
Backend Validation → Read JSON → Append Todo → Write JSON → 
Return New Todo → Update Frontend State → Render UI
```

### Complete Todo Flow
```
User Click → PUT /api/todos/<id>/complete → 
Read JSON → Find Todo → Update completed=true → Write JSON → 
Return Updated Todo → Update Frontend State → Render UI
```

### List Todos Flow
```
Page Load → GET /api/todos → 
Read JSON → Return All Todos → 
Populate Frontend State → Render UI
```

## Potential Challenges

1. **Concurrent Access**
   - **Issue**: Multiple requests modifying JSON simultaneously could corrupt data
   - **Solution**: Implement file locking (fcntl on Unix, msvcrt on Windows) or use atomic writes with optimistic locking

2. **File Corruption**
   - **Issue**: Power loss or crash during write could corrupt JSON
   - **Solution**: Write to temp file first, then atomic rename; keep backup of last valid state

3. **Performance with Large Datasets**
   - **Issue**: Loading entire file for each operation becomes slow with 1000+ todos
   - **Solution**: For MVP, limit to reasonable size (~500 items); document migration path to database

4. **ID Generation**
   - **Issue**: Need unique IDs without database auto-increment
   - **Solution**: Use UUID4 or timestamp-based IDs; UUID recommended for uniqueness guarantee

5. **CORS Configuration**
   - **Issue**: Frontend and backend on different ports during development
   - **Solution**: Configure CORS properly in Flask/Express; document production deployment

6. **Date/Time Handling**
   - **Issue**: Timezone inconsistencies between client and server
   - **Solution**: Store all timestamps in UTC (ISO-8601 format); handle timezone conversion on frontend

## Recommendations

### Phase 1: MVP Implementation
1. **Backend First**: Implement Flask app with core endpoints (add, list, complete)
2. **Storage Layer**: Create robust JSON file handler with atomic writes
3. **Basic Frontend**: Simple HTML form and list view with vanilla JS
4. **Testing**: Manual testing of all operations

### Phase 2: Polish
1. Add delete functionality
2. Implement filtering (completed/active)
3. Add search/sort capabilities
4. Improve UI/UX with better styling
5. Add client-side validation

### Development Workflow
1. Start with backend API development and testing (use Postman/curl)
2. Create minimal frontend once API is stable
3. Iterate on UX improvements
4. Add error handling and edge cases

### Key Implementation Files

**backend/storage.py** (Critical)
```python
class TodoStorage:
    def __init__(self, filepath="data/todos.json")
    def read_todos() -> list
    def write_todos(todos: list) -> None
    def add_todo(todo: dict) -> dict
    def update_todo(id: str, updates: dict) -> dict
    def delete_todo(id: str) -> bool
```

**backend/app.py** (Entry Point)
```python
from flask import Flask, jsonify, request
from storage import TodoStorage

app = Flask(__name__)
storage = TodoStorage()

@app.route('/api/todos', methods=['GET', 'POST'])
# ... implement endpoints
```

**frontend/app.js** (Client Logic)
```javascript
const API_BASE = 'http://localhost:5000/api';

async function fetchTodos() { ... }
async function addTodo(title, description) { ... }
async function completeTodo(id) { ... }
function renderTodos(todos) { ... }
```

### Production Considerations
- Environment variables for configuration (port, file path)
- Input sanitization for XSS prevention
- Rate limiting for API endpoints
- Backup strategy for todos.json
- Docker containerization for easy deployment
- Consider migration path to SQLite/PostgreSQL if scaling needed