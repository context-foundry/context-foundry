# Research Report: Web-Based Todo App
Generated: 2025-10-04 09:56:23 UTC
Context Usage: <5%

## Architecture Overview

A simple web-based todo application with a client-server architecture:
- **Frontend**: Single-page application (HTML/CSS/JavaScript)
- **Backend**: Node.js/Express API server
- **Storage**: Local JSON file (todos.json)
- **Operations**: Add, list, and complete todos via REST API

This is a greenfield project requiring minimal dependencies and a straightforward request-response pattern.

## Technology Stack Recommendations

### Backend
- **Runtime**: Node.js (v18+)
- **Framework**: Express.js (lightweight, well-documented)
- **Storage**: Native `fs/promises` module for JSON file I/O
- **Dependencies**: 
  - `express` (~4.18.x) - HTTP server
  - `cors` - Enable frontend access
  - `body-parser` or express.json() - Parse request bodies

### Frontend
- **Vanilla HTML/CSS/JavaScript** (no framework needed for this scope)
- **Fetch API** for HTTP requests
- **LocalStorage** optional for client-side caching

## Project Structure

```
todo-web/
├── package.json
├── server.js              # Express server entry point
├── data/
│   └── todos.json         # Persistent storage
├── public/
│   ├── index.html         # Main UI
│   ├── style.css          # Styling
│   └── app.js             # Frontend logic
└── routes/
    └── todos.js           # API route handlers
```

## Data Models

### Todo Schema
```json
{
  "id": "string (UUID or timestamp)",
  "text": "string",
  "completed": "boolean",
  "createdAt": "ISO 8601 timestamp",
  "completedAt": "ISO 8601 timestamp | null"
}
```

### Storage Format (todos.json)
```json
{
  "todos": [
    {
      "id": "1234567890",
      "text": "Example task",
      "completed": false,
      "createdAt": "2025-10-04T09:56:23Z",
      "completedAt": null
    }
  ]
}
```

## API Endpoints

| Method | Endpoint | Purpose | Request Body | Response |
|--------|----------|---------|--------------|----------|
| GET | `/api/todos` | List all todos | - | `{ todos: [...] }` |
| POST | `/api/todos` | Add new todo | `{ text: "..." }` | `{ todo: {...} }` |
| PATCH | `/api/todos/:id/complete` | Mark complete | - | `{ todo: {...} }` |

## Implementation Patterns

### 1. File Storage Pattern
```javascript
// Atomic read-modify-write with error handling
async function readTodos() {
  const data = await fs.readFile('data/todos.json', 'utf-8');
  return JSON.parse(data);
}

async function writeTodos(todos) {
  await fs.writeFile('data/todos.json', JSON.stringify(todos, null, 2));
}
```

**Key considerations**:
- Initialize `todos.json` with `{ "todos": [] }` if missing
- Use `fs.promises` for async/await pattern
- Handle `ENOENT` errors gracefully

### 2. ID Generation
- Use `Date.now()` for simple numeric IDs
- Or `crypto.randomUUID()` for true UUIDs (Node 14.17+)

### 3. Error Handling
- Validate request body (text must be non-empty string)
- Handle 404 for non-existent todo IDs
- Return appropriate HTTP status codes (200, 201, 400, 404, 500)

### 4. Frontend State Management
- Fetch todos on page load
- Optimistic UI updates (update DOM immediately, revert on error)
- Simple event listeners for form submission and button clicks

## Data Flow

### Add Todo
1. User submits form → POST `/api/todos`
2. Server validates input
3. Read current todos from JSON file
4. Generate new ID, create todo object
5. Append to array, write to file
6. Return new todo to client
7. Client appends to DOM

### List Todos
1. Page load → GET `/api/todos`
2. Server reads JSON file
3. Returns todos array
4. Client renders list with complete buttons

### Complete Todo
1. User clicks "Complete" → PATCH `/api/todos/:id/complete`
2. Server reads todos, finds by ID
3. Update `completed: true`, set `completedAt`
4. Write to file, return updated todo
5. Client updates DOM (strikethrough, disable button)

## Potential Challenges

### 1. Concurrent Writes
**Issue**: Multiple simultaneous requests could cause race conditions when reading/modifying/writing JSON file.

**Mitigation**: 
- For this scope, acceptable risk (single-user app)
- Future: Implement file locking or use SQLite

### 2. File Corruption
**Issue**: Incomplete writes during crashes could corrupt JSON.

**Mitigation**:
- Write to temporary file first, then rename (atomic operation)
- Keep backup of last known good state

### 3. ID Collisions
**Issue**: `Date.now()` could generate duplicate IDs if requests are rapid.

**Mitigation**: Use `crypto.randomUUID()` instead

### 4. Scalability
**Issue**: Reading entire file on every request is inefficient for large datasets.

**Note**: Acceptable for <1000 todos; beyond that, migrate to database

## Recommendations

### Phase 1: Minimum Viable Product
1. Set up Express server with static file serving
2. Implement three API endpoints with basic validation
3. Create simple HTML form and list UI
4. Use `fs.promises` with try-catch error handling
5. Initialize empty todos.json on first run

### Phase 2: Enhancements (Optional)
- Add delete functionality
- Filter (show all/active/completed)
- Edit todo text
- Persist sort order
- Add timestamps display

### Key Implementation Order
1. **Backend first**: Server + API + JSON storage (testable with curl/Postman)
2. **Frontend second**: HTML structure + JavaScript fetch calls
3. **Styling last**: CSS for polish

### Testing Strategy
- Manual API testing with curl or Postman
- Browser console for frontend debugging
- Test edge cases: empty text, invalid IDs, missing file

### Dependencies to Install
```bash
npm init -y
npm install express cors
```

### Critical Files to Create
1. `server.js` - ~50 lines (setup + static serving)
2. `routes/todos.js` - ~80 lines (CRUD operations)
3. `public/index.html` - ~40 lines (form + list container)
4. `public/app.js` - ~60 lines (fetch calls + DOM manipulation)
5. `data/todos.json` - Initialize with `{"todos":[]}`

**Total Estimated LOC**: ~250 lines

This is a straightforward CRUD application with well-established patterns. Main focus should be on clean error handling and proper HTTP semantics.